\chapter{Testing}
During this project two testing approaches have been used to verify that the converter is capable of a correct conversion. On one hand, simple input/output testing was used to test the demos and the converter during the early stages of the project. This form of testing helped to investigate how to use the JSBML and ERODE libraries and figuring out how to realize the most basic conversion steps in code.

Once the first conversion steps were implemented and familiarity with those libraries were obtained, the development process began turning more and more into a test-driven (TDD)/behaviour-driven (BDD) development process. Using the cucumber testing tool, test were defined to assess the program behaviour, which then were implemented. Every time a new feature was implemented all test were run again, failed test were analyzed and problems were fixed, before moving on the next feature.

In addition to the tests, a code coverage tool was used to analyze, which lines of code in the converter were executed during the tests. Code segments that were not covered by the tests were then analyzed, in order to ascertain the reason why they did not run. Mostly, this was due to certain scenarios not being tested. In other rare cases, it was also due to the fact that there was no scenario being able to reach those lines. Depending on the case, either new test scenarios were then added to verify missing code segments, or code segments simply were removed, due to not being needed.

As a final means of testing, some end-to-end testing has been performed, by converting an real-world SBML-model to ERODE and back. The conversion result was then compared to the original, to see if they still represented the same model. Eventually, the converter had been tested and improved to the point, where such a conversion succeeded.

When looking at, what kind of tests were implemented, it can be seen that the majority are success tests. This is due to the fact, that the most important feature of the converter is that it should be able to convert valid models correctly. Since the representations for both formats, for these models, are obtained through external library plugins, only a limited amount of failure testing was required. This was due to the fact, the plugins used by the converted validate the models before handing them on to the converter. Of course, the converter cannot do completely without failure tests, as it only can convert valid SBML-qual models. It was therefore, necessary to implement some error handling and failure testing, to assert that only valid SBML-qual models are converted. In case of non-SBML-qual models, the converter simply reports the error and the conversion fails.

